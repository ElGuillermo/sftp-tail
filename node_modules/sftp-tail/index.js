import crypto from 'crypto';
import EventEmitter from 'events';
import fs from 'fs';
import path from 'path';

import Client from 'ssh2-sftp-client';

export default class SFTPTail extends EventEmitter {
  constructor(options) {
    super();

    this.options = {
      host: options.host,
      port: options.port,
      user: options.user,
      password: options.password,
      verbose: options.verbose,
      encoding: options.encoding || 'utf8',
      path: options.path,
      fetchInterval: options.fetchInterval || 0,
      tailLastBytes: 10 * 1000,
    };

    this.tempFilePath = path.join(
      process.cwd(),
      crypto
        .createHash('md5')
        .update(`${this.options.host}:${this.options.port}:${this.options.path}`)
        .digest('hex') + '.tmp'
    );

    this.lastByteReceived = null;
  }

  async fetchLoop() {
    while (this.fetchInterval !== -1) {
      try {
        const fetchStartTime = Date.now();

        // reconnect the client if not connected already
        if (this.client.closed) {
          this.log('Reconnecting...');
          await this.client.connect({
            host: this.options.host,
            port: this.options.port,
            username: this.options.user,
            password: this.options.password,
          });
          this.emit('reconnect');
          this.log('Reconnected.');
        }

        // get size of file on remote
        this.log('Fetching size of remote file');
        const remote_fileSize_stat = await this.client.stat(this.options.path)
        const remote_fileSize = remote_fileSize_stat.size
        this.log(`Remote file size is ${remote_fileSize}`);

        // if file has not been tailed before then download last few bytes
        if (this.lastByteReceived === null || remote_fileSize < this.lastByteReceived) {
          this.lastByteReceived = Math.max(0, remote_fileSize - this.options.tailLastBytes);
          this.log('Tailing new file.');
          // console.log('---------- Tailing new file. ----------');
        } else if (this.lastByteReceived === remote_fileSize) {
          this.log('File has not changed.');
          // console.log('---------- File has not changed. ----------');
          await this.sleep();
          continue;
        }

        // copy the whole file
        this.log('Downloading remote file');
        let fastget_options = {
          concurrency: 64,
          chunkSize: 32768
        }
        await this.client.fastGet(
          this.options.path,
          this.tempFilePath,
          fastget_options
        )
        this.log(`Remote file downloaded`);

        // only keep the last bytes, as defined in options.tailLastBytes
        const local_filesize = fs.statSync(this.tempFilePath).size;
        if (local_filesize <= this.options.tailLastBytes) {
          console.log('Local file size is <= the number of bytes to keep.');
        }
        else {
          const buffer = Buffer.alloc(this.options.tailLastBytes);
          const fileDescriptor = fs.openSync(this.tempFilePath, 'r');
          fs.readSync(fileDescriptor, buffer, 0, this.options.tailLastBytes, local_filesize - this.options.tailLastBytes);
          fs.closeSync(fileDescriptor);
          fs.writeFileSync(this.tempFilePath, buffer);
        }

        // update the last byte marker - this is so we can get data since this position on the next ftp download
        // const downloadSize = fs.statSync(this.tempFilePath).size;
        const local_newfile_size = fs.statSync(this.tempFilePath).size;
        this.lastByteReceived += local_newfile_size;
        this.log(`Local file size is ${local_newfile_size}.`);

        // get contents of file
        const data = await fs.promises.readFile(this.tempFilePath, 'utf8');

        // only continue if something was fetched
        if (data.length > 0) {
          data
            // strip tailing new lines
            .replace(/\r\n$/, '')
            // split on the lines
            .split('\r\n')
            // emit each line
            .forEach((line) => this.emit('line', line));
        }

        // log fetch time
        const fetchEndTime = Date.now();
        const fetchTime = fetchEndTime - fetchStartTime;
        if (this.options.verbose) this.log(`SFTP Fetch took ${fetchTime} ms.`);

        // wait for next fetch
        await this.sleep();
      } catch (err) {
        this.log(`Error: ${err.message}`);
        this.emit('error', err);
      }
    }

    // disconnect
    if (!this.client.closed) {
      // await this.client.close();
      await this.client.end(); // EG
      this.emit('disconnect');
      this.log('Disconnected.');
    }

    // delete temp file
    if (fs.existsSync(this.tempFilePath)) {
      this.log(`Deleting temp file ${this.tempFilePath}...`);
      fs.unlinkSync(this.tempFilePath);
    }
  }

  async sleep() {
    if (this.fetchInterval > 0) {
      this.log(`Sleeping ${this.fetchInterval} ms...`);
      await new Promise((resolve) => setTimeout(resolve, this.fetchInterval));
    }
  }

  async watch() {
    // setup client
    this.log('Initialising client...');
    // this.client = new ftp.Client(this.options.timeout);
    this.client = new Client() // EG
    // if (this.options.verbose && this.options.verbose >= 2)
    //  this.client.ftp.verbose = this.options.verbose;
    // if (this.options.encoding) this.client.ftp.encoding = this.options.encoding;

    // connect
    this.log('Connecting...');
    // await this.client.access({
    await this.client.connect({ // EG
      host: this.options.host,
      port: this.options.port,
      // user: this.options.user,
      username: this.options.user, // EG
      password: this.options.password,
      // secure: this.options.secure,
    });
    this.emit('connect');
    this.log('Connected.');

    // start fetch loop
    this.log('Commencing fetch loop...');
    this.fetchInterval = this.options.fetchInterval;
    this.fetchLoop();
  }

  async unwatch() {
    this.fetchInterval = -1;
  }

  log(msg) {
    if (this.options.verbose >= 1) console.log(`[${Date.now()}] FFTPTail (Verbose): ${msg}`);
  }

  async listSize(remotePath) {
    const parsedPath = path.parse(remotePath);
    const fileInfos = await this.client.list(parsedPath.dir); // EG seems ok

    const matches = fileInfos.filter((info) => info.name === parsedPath.base);

    if (matches.length === 0) {
      throw new Error('unable to get file size: no matching files');
    }

    if (matches.length > 1) {
      throw new Error(`unable to get file size: multiple matching files: ${matches.length}`);
    }

    return matches[0].size;
  }
}
