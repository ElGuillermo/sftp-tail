import crypto from 'crypto';
import EventEmitter from 'events';
import fs from 'fs';
import path from 'path';

import Client from 'ssh2-sftp-client';

export default class SFTPTail extends EventEmitter {
  constructor(options) {
    super();

    this.options = {
      host: options.host,
      port: options.port,
      user: options.user,
      password: options.password,
      verbose: options.verbose,
      encoding: options.encoding || 'utf8',
      path: options.path,
      fetchInterval: options.fetchInterval || 0,
      tailLastBytes: 10 * 1000,
    };

    this.tempFilePath = path.join(
      process.cwd(),
      crypto
        .createHash('md5')
        .update(`${this.options.host}:${this.options.port}:${this.options.path}`)
        .digest('hex') + '.tmp'
    );

    this.lastByteReceived = null;
  }

  createNewFileFromLastNBytes(inputFilePath, outputFilePath, n) {
    fs.stat(inputFilePath, (err, stats) => {
      if (err) {
        console.error(err);
        return;
      }
      const fileSize = stats.size;
      const start = Math.max(0, fileSize - n);
      const buffer = Buffer.alloc(n);
      fs.open(inputFilePath, 'r', (err, fd) => {
        if (err) {
          console.error(err);
          return;
        }
        fs.read(fd, buffer, 0, n, start, (err, bytesRead, buffer) => {
          if (err) {
            console.error(err);
            return;
          }
          fs.close(fd, (err) => {
            if (err) {
              console.error(err);
              return;
            }
            fs.writeFile(outputFilePath, buffer, (err) => {
              if (err) {
                console.error(err);
                return;
              }
              // console.log(`New file created from last ${n} bytes of ${inputFilePath}`);
            });
          });
        });
      });
    });
  }

  async fetchLoop() {
    while (this.fetchInterval !== -1) {
      try {
        const fetchStartTime = Date.now();

        // reconnect the client if not connected already
        if (this.client.closed) {
          this.log('Reconnecting...');
          await this.client.connect({
            host: this.options.host,
            port: this.options.port,
            username: this.options.user,
            password: this.options.password,
          });
          this.emit('reconnect');
          this.log('Reconnected.');
        }

        // Get distant file size
        const fileSize_stat = await this.client.stat(this.options.path);
        const fileSize = fileSize_stat.size;

        // Check if distant file has changed
        if (this.lastByteReceived === fileSize) {
          await this.sleep();
          continue;
        }

        // Distant file has changed - Download the whole file
        this.complete_copy_name = this.tempFilePath + '.complete';
        let fastget_options = {
          concurrency: 64,
          chunkSize: 32768
        }
        await this.client.fastGet(
          this.options.path,
          this.complete_copy_name,
          fastget_options
        );

        // Get local file size
        let downloadSize = fs.statSync(this.complete_copy_name).size;

        // Evaluate the new data set size
        if (downloadSize > this.lastByteReceived) {
          var new_bytes_len = downloadSize - this.lastByteReceived;

          // Copy the new data set from the local complete file in the file that will be parsed
          this.createNewFileFromLastNBytes(this.complete_copy_name, this.tempFilePath, new_bytes_len);

          // Update last data read position
          this.lastByteReceived = downloadSize;

          // get contents of file
          const data = await fs.promises.readFile(this.tempFilePath, 'utf8');

          // only continue if something was fetched
          if (data.length > 0) {
            data
              // strip tailing new lines
              .replace(/\r\n$/, '')
              // split on the lines
              .split('\r\n')
              // emit each line
              .forEach((line) => this.emit('line', line));
          }

          // log fetch time
          const fetchEndTime = Date.now();
          const fetchTime = fetchEndTime - fetchStartTime;
          if (this.options.verbose) this.log(`SFTP Fetch took ${fetchTime} ms.`);

        // } else if (downloadSize === this.lastByteReceived) {
        //   var new_bytes_len = 0;
        // }
        }

        // wait for next fetch
        await this.sleep();

      } catch (err) {
        this.log(`Error: ${err.message}`);
        this.emit('error', err);
      }
    }

    // disconnect
    if (!this.client.closed) {
      await this.client.end();
      this.emit('disconnect');
      this.log('Disconnected.');
    }

    // delete temp file
    if (fs.existsSync(this.tempFilePath)) {
      this.log(`Deleting temp file ${this.tempFilePath}...`);
      fs.unlinkSync(this.tempFilePath);
    }
  }

  async sleep() {
    if (this.fetchInterval > 0) {
      this.log(`Sleeping ${this.fetchInterval} ms...`);
      await new Promise((resolve) => setTimeout(resolve, this.fetchInterval));
    }
  }

  async watch() {
    // setup client
    this.log('Initialising client...');
    this.client = new Client()

    // connect
    this.log('Connecting...');
    await this.client.connect({
      host: this.options.host,
      port: this.options.port,
      username: this.options.user,
      password: this.options.password,
    });
    this.emit('connect');
    this.log('Connected.');

    // start fetch loop
    this.log('Commencing fetch loop...');
    this.fetchInterval = this.options.fetchInterval;
    this.fetchLoop();
  }

  async unwatch() {
    this.fetchInterval = -1;
  }

  log(msg) {
    if (this.options.verbose >= 1) console.log(`[${Date.now()}] SFTPTail (Verbose): ${msg}`);
  }
}
