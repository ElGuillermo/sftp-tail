import crypto from 'crypto';
import EventEmitter from 'events';
import fs from 'fs';
import path from 'path';

import Client from 'ssh2-sftp-client';

export default class SFTPTail extends EventEmitter {
  constructor(options) {
    super();

    this.options = {
      host: options.host,
      port: options.port,
      user: options.user,
      password: options.password,
      verbose: options.verbose,
      encoding: options.encoding || 'utf8',
      path: options.path,
      fetchInterval: options.fetchInterval || 0,
      tailLastBytes: 10 * 1000,
    };

    this.tempFilePath = path.join(
      process.cwd(),
      crypto
        .createHash('md5')
        .update(`${this.options.host}:${this.options.port}:${this.options.path}`)
        .digest('hex') + '.tmp'
    );

    this.lastByteReceived = null;
  }

  createNewFileFromLastNBytes(inputFilePath, outputFilePath, n) {
    fs.stat(inputFilePath, (err, stats) => {
      if (err) {
        console.error(err);
        return;
      }
      const fileSize = stats.size;
      const start = Math.max(0, fileSize - n);
      const buffer = Buffer.alloc(n);
      fs.open(inputFilePath, 'r', (err, fd) => {
        if (err) {
          console.error(err);
          return;
        }
        fs.read(fd, buffer, 0, n, start, (err, bytesRead, buffer) => {
          if (err) {
            console.error(err);
            return;
          }
          fs.close(fd, (err) => {
            if (err) {
              console.error(err);
              return;
            }
            fs.writeFile(outputFilePath, buffer, (err) => {
              if (err) {
                console.error(err);
                return;
              }
              console.log(`New file created from last ${n} bytes of ${inputFilePath}`);
            });
          });
        });
      });
    });
  }

  async fetchLoop() {
    while (this.fetchInterval !== -1) {
      try {
        const fetchStartTime = Date.now();

        // reconnect the client if not connected already
        if (this.client.closed) {
          this.log('Reconnecting...');
          await this.client.connect({
            host: this.options.host,
            port: this.options.port,
            username: this.options.user,
            password: this.options.password,
          });
          this.emit('reconnect');
          this.log('Reconnected.');
        }

        // Patch start

        // get size of file on remote
        this.log('Fetching size of remote file');
        // console.log('Fetching size of remote file');
        const fileSize_stat = await this.client.stat(this.options.path);
        const fileSize = fileSize_stat.size;
        this.log(`File size is ${fileSize}.`);
        // console.log(`File size is ${fileSize}.`);

        // if file has not been tailed before then download last few bytes
        if (this.lastByteReceived === null || this.lastByteReceived < fileSize) {
          this.log('Tailing new file.');
          console.log('Tailing new file.');
          // this.lastByteReceived = Math.max(0, fileSize);
        } else if (this.lastByteReceived === fileSize) {
          this.log('File has not changed.');
          // console.log('File has not changed.');
          await this.sleep();
          continue;
        }

        // Download the data to a temp file, overwrite any previous data
        // overwrite previous data to calculate how much data we've received
        this.log(`Downloading file with offset of ${this.lastByteReceived}...`);
        console.log(`Downloading file with offset of ${this.lastByteReceived}...`);

        // copy the whole file
        this.log('Downloading complete file');
        // console.log('Downloading complete file');
        this.complete_copy_name = this.tempFilePath + '.complete';
        let fastget_options = {
          concurrency: 64,
          chunkSize: 32768
        }
        await this.client.fastGet(
          this.options.path,
          this.complete_copy_name,
          fastget_options
        );
        this.log(`Downloaded complete file.`);
        // console.log(`Downloaded complete file.`);

        // update the last byte marker - this is so we can get data since this position on the next ftp download
        let downloadSize = fs.statSync(this.complete_copy_name).size;
        this.log(`Downloaded file size if ${downloadSize}.`);
        console.log(`Downloaded file size if ${downloadSize}.`);


        // const new_bytes_len = 0;
        if (downloadSize > this.lastByteReceived) {
          var new_bytes_len = downloadSize - this.lastByteReceived;
          console.log(`+ new_bytes_len is ${new_bytes_len}.`);
        } else if (downloadSize === this.lastByteReceived) {
          var new_bytes_len = 0;
          console.log(`0 new_bytes_len is ${new_bytes_len}.`);
        }
        console.log(`sum new_bytes_len is ${new_bytes_len}.`);
        // console.log(typeof new_bytes_len);

        // lire this.complete_copy_name depuis l'offset new_bytes_len jusqu'Ã  la fin
        // et sauver le tout dans this.tempFilePath
        this.createNewFileFromLastNBytes(this.complete_copy_name, this.tempFilePath, new_bytes_len);

        // this.lastByteReceived += downloadSize;
        this.lastByteReceived = downloadSize;
        console.log(`this.lastByteReceived = ${this.lastByteReceived}.` );

        // get contents of file
        const data = await fs.promises.readFile(this.tempFilePath, 'utf8');

        // only continue if something was fetched
        if (data.length > 0) {
          data
            // strip tailing new lines
            .replace(/\r\n$/, '')
            // split on the lines
            .split('\r\n')
            // emit each line
            .forEach((line) => this.emit('line', line));
        }

        // log fetch time
        const fetchEndTime = Date.now();
        const fetchTime = fetchEndTime - fetchStartTime;
        if (this.options.verbose) this.log(`SFTP Fetch took ${fetchTime} ms.`);

        // wait for next fetch
        await this.sleep();
      } catch (err) {
        this.log(`Error: ${err.message}`);
        this.emit('error', err);
      }
    }

    // disconnect
    if (!this.client.closed) {
      // await this.client.close();
      await this.client.end(); // EG
      this.emit('disconnect');
      this.log('Disconnected.');
    }

    // delete temp file
    if (fs.existsSync(this.tempFilePath)) {
      this.log(`Deleting temp file ${this.tempFilePath}...`);
      fs.unlinkSync(this.tempFilePath);
    }
  }

  async sleep() {
    if (this.fetchInterval > 0) {
      this.log(`Sleeping ${this.fetchInterval} ms...`);
      await new Promise((resolve) => setTimeout(resolve, this.fetchInterval));
    }
  }

  async watch() {
    // setup client
    this.log('Initialising client...');
    // this.client = new ftp.Client(this.options.timeout);
    this.client = new Client() // EG
    // if (this.options.verbose && this.options.verbose >= 2)
    //  this.client.ftp.verbose = this.options.verbose;
    // if (this.options.encoding) this.client.ftp.encoding = this.options.encoding;

    // connect
    this.log('Connecting...');
    // await this.client.access({
    await this.client.connect({ // EG
      host: this.options.host,
      port: this.options.port,
      // user: this.options.user,
      username: this.options.user, // EG
      password: this.options.password,
      // secure: this.options.secure,
    });
    this.emit('connect');
    this.log('Connected.');

    // start fetch loop
    this.log('Commencing fetch loop...');
    this.fetchInterval = this.options.fetchInterval;
    this.fetchLoop();
  }

  async unwatch() {
    this.fetchInterval = -1;
  }

  log(msg) {
    if (this.options.verbose >= 1) console.log(`[${Date.now()}] FFTPTail (Verbose): ${msg}`);
  }

  async listSize(remotePath) {
    const parsedPath = path.parse(remotePath);
    const fileInfos = await this.client.list(parsedPath.dir); // EG seems ok

    const matches = fileInfos.filter((info) => info.name === parsedPath.base);

    if (matches.length === 0) {
      throw new Error('unable to get file size: no matching files');
    }

    if (matches.length > 1) {
      throw new Error(`unable to get file size: multiple matching files: ${matches.length}`);
    }

    return matches[0].size;
  }
}
